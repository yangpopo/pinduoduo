{"version":3,"sources":["assets/js/mescroll.min.js"],"names":["name","definition","module","exports","this","MeScroll","mescrollId","options","me","version","isScrollBody","scrollDom","document","body","getDomById","u","navigator","userAgent","isIOS","match","isPC","window","orientation","isAndroid","indexOf","isWx","toLowerCase","os","ios","pc","android","wx","isDownScrolling","isUpScrolling","hasDownCallback","down","callback","initDownScroll","initUpScroll","setTimeout","optDown","use","auto","autoShowLoading","triggerDownScroll","optUp","isUpAutoLoad","triggerUpScroll","prototype","extendDownScroll","extend","isLock","isBoth","offset","inOffsetRate","outOffsetRate","bottomOffset","minAngle","hardwareClass","mustToTop","warpId","warpClass","resetClass","textInOffset","textOutOffset","textLoading","htmlContent","inited","mescroll","downwarp","downTipDom","getElementsByClassName","downProgressDom","inOffset","innerHTML","classList","remove","outOffset","onMoving","rate","downHight","progress","style","webkitTransform","transform","beforeLoading","showLoading","add","afterLoading","resetUpScroll","extendUpScroll","isBounce","page","num","size","time","noMoreSize","toTop","src","html","showClass","hideClass","fadeDuration","duration","supportTap","btnClick","loadFull","delay","empty","customId","icon","tip","btntext","clearId","clearEmptyId","htmlLoading","htmlNodata","upwarp","showNoMore","onScroll","scrollbar","barClass","lazyLoad","attr","userOption","defaultOption","key","touchstartEvent","e","isScrollTo","preventDefault","startPoint","getPoint","lastPoint","maxTouchmoveY","getBodyHeight","inTouchend","scrollTop","getScrollTop","isKeepTop","addEventListener","touchmoveEvent","passive","ondragstart","curPoint","moveY","y","x","Math","abs","z","sqrt","asin","PI","touchendEvent","diff","movetype","isMoveDown","webkitOverflowScrolling","isSetScrollAuto","height","scrollHeight","getScrollHeight","clientHeight","getClientHeight","toBottom","hasNext","removeEventListener","createElement","className","downparent","appendChild","insertBefore","firstChild","cancelable","defaultPrevented","touches","pageX","clientX","pageY","clientY","showDownScroll","endDownScroll","endScroll","lockDownScroll","upparent","up","setBounce","preScrollY","lazyStartTime","Date","getTime","lazyTag","scrollEvent","isUp","optTop","showTopBtn","hideTopBtn","curTime","lazyTimer","clearTimeout","bounceTouchmove","el","target","isPrevent","cls","contains","curX","curY","preWinX","preWinY","angle","parentNode","showUpScroll","visibility","display","hideUpScroll","displayAble","upProgressDom","endUpScroll","isShowNoMore","isShowLoading","prePageNum","prePageTime","removeEmpty","clearDataList","setPageNum","setPageSize","listId","listDom","endByPage","dataSize","totalPage","systime","endSuccess","endBySize","totalSize","pageNum","pageSize","showEmpty","endErr","lockUpScroll","optEmpty","emptyDom","emptyWarp","str","emptyBtn","stopPropagation","onclick","removeChild","topBtnShow","warpDom","toTopBtn","scrollTo","setTopBtnFadeDuration","animationDuration","webkitAnimationDuration","t","star","end","maxY","getStep","step","setScrollTop","count","i","timer","setInterval","clearInterval","domArr","querySelectorAll","len","length","dom","getAttribute","isInSee","imgurl","temp","Image","onload","tagName","backgroundImage","removeAttribute","onerror","onabort","setAttribute","topDom","getOffsetTop","topSee","bottomDom","offsetHeight","bottomSee","top","offsetTop","parent","offsetParent","clientTop","compatMode","documentElement","getToBottom","id","getElementById","nodeType","console","error","destroy"],"mappings":"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","file":"static/js/1.c21d7459.chunk.js","sourcesContent":["/* mescroll\r\n * version 1.4.2\r\n * 2019-08-01 wenju\r\n * http://www.mescroll.com\r\n */\r\n(function (name, definition) {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    // 定义为普通Node模块\r\n    module.exports = definition();\r\n  } else {\r\n    // 将模块的执行结果挂在window变量中，在浏览器中this指向window对象\r\n    this[name] = definition();\r\n  }\r\n})('MeScroll', function () {\r\n  var MeScroll = function (mescrollId, options) {\r\n    var me = this;\r\n    me.version = '1.4.2'; // mescroll版本号\r\n    me.isScrollBody = (!mescrollId || mescrollId === 'body'); // 滑动区域是否为body\r\n    me.scrollDom = me.isScrollBody ? document.body : me.getDomById(mescrollId); // MeScroll的滑动区域\r\n    if (!me.scrollDom) return;\r\n\r\n    me.options = options || {}; // 配置\r\n\r\n    var u = navigator.userAgent;\r\n    var isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); // 是否为ios设备\r\n    var isPC = typeof window.orientation === 'undefined'; // 是否为PC端\r\n    var isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;// 是否为android端\r\n    var isWx = u.toLowerCase().match(/MicroMessenger/i) == 'micromessenger'; // 是否为微信端,此处不能为===,因为match的结果可能是null或数组\r\n    \r\n    me.os = {\r\n      ios: isIOS,\r\n      pc: isPC,\r\n      android: isAndroid,\r\n      wx: isWx\r\n    }\r\n\r\n    me.isDownScrolling = false; // 是否在执行下拉刷新的回调\r\n    me.isUpScrolling = false; // 是否在执行上拉加载的回调\r\n    var hasDownCallback = me.options.down && me.options.down.callback; // 是否配置了down的callback\r\n\r\n    // 初始化下拉刷新\r\n    me.initDownScroll();\r\n    // 初始化上拉加载,则初始化\r\n    me.initUpScroll();\r\n\r\n    // 自动加载\r\n    setTimeout(function () { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\r\n      // 自动触发下拉刷新 (只有配置了down的callback才自动触发下拉刷新)\r\n      if (me.optDown.use && me.optDown.auto && hasDownCallback) {\r\n        if (me.optDown.autoShowLoading) {\r\n          me.triggerDownScroll(); // 显示下拉进度,执行下拉回调\r\n        } else {\r\n          me.optDown.callback && me.optDown.callback(me); // 不显示下拉进度,直接执行下拉回调\r\n        }\r\n      }\r\n      // 自动触发上拉加载\r\n      me.optUp.use && me.optUp.auto && !me.isUpAutoLoad && me.triggerUpScroll();\r\n    }, 30); // 需让me.optDown.inited和me.optUp.inited先执行\r\n  }\r\n\r\n  /* 配置参数:下拉刷新 */\r\n  MeScroll.prototype.extendDownScroll = function (optDown) {\r\n    // 下拉刷新的配置\r\n    MeScroll.extend(optDown, {\r\n      use: true, // 是否启用下拉刷新; 默认true\r\n      auto: true, // 是否在初始化完毕之后自动执行下拉刷新的回调; 默认true\r\n      autoShowLoading: false, // 如果设置auto=true(在初始化完毕之后自动执行下拉刷新的回调),那么是否显示下拉刷新的进度; 默认false\r\n      isLock: false, // 是否锁定下拉刷新,默认false;\r\n      isBoth: false, // 下拉刷新时,如果滑动到列表底部是否可以同时触发上拉加载;默认false,两者不可同时触发;\r\n      offset: 80, // 在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调\r\n      inOffsetRate: 1, // 在列表顶部,下拉的距离小于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\r\n      outOffsetRate: 0.2, // 在列表顶部,下拉的距离大于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉\r\n      bottomOffset: 20, // 当手指touchmove位置在距离body底部20px范围内的时候结束上拉刷新,避免Webview嵌套导致touchend事件不执行\r\n      minAngle: 45, // 向下滑动最少偏移的角度,取值区间  [0,90];默认45度,即向下滑动的角度大于45度则触发下拉;而小于45度,将不触发下拉,避免与左右滑动的轮播等组件冲突;\r\n      hardwareClass: 'mescroll-hardware', // 硬件加速样式,解决部分手机闪屏或动画不流畅的问题\r\n      mustToTop: false, // 是否滚动条必须在顶部,才可以下拉刷新.默认false. 当您发现下拉刷新会闪白屏时,设置true即可修复.\r\n      warpId: null, // 可配置下拉刷新的布局添加到指定id的div;默认不配置,默认添加到mescrollId\r\n      warpClass: 'mescroll-downwarp', // 下拉刷新的布局容器样式,参见mescroll.css\r\n      resetClass: 'mescroll-downwarp-reset', // 下拉刷新高度重置的动画,参见mescroll.css\r\n      textInOffset: '下拉刷新', // 下拉的距离在offset范围内的提示文本\r\n      textOutOffset: '释放更新', // 下拉的距离大于offset范围的提示文本\r\n      textLoading: '加载中 ...', // 加载中的提示文本\r\n      htmlContent: '<p class=\"downwarp-progress\"></p><p class=\"downwarp-tip\"></p>', // 布局内容\r\n      inited: function (mescroll, downwarp) {\r\n        // 下拉刷新初始化完毕的回调\r\n        mescroll.downTipDom = downwarp.getElementsByClassName('downwarp-tip')[0];\r\n        mescroll.downProgressDom = downwarp.getElementsByClassName('downwarp-progress')[0];\r\n      },\r\n      inOffset: function (mescroll) {\r\n        // 下拉的距离进入offset范围内那一刻的回调\r\n        if (mescroll.downTipDom) mescroll.downTipDom.innerHTML = mescroll.optDown.textInOffset;\r\n        if (mescroll.downProgressDom) mescroll.downProgressDom.classList.remove('mescroll-rotate');\r\n      },\r\n      outOffset: function (mescroll) {\r\n        // 下拉的距离大于offset那一刻的回调\r\n        if (mescroll.downTipDom) mescroll.downTipDom.innerHTML = mescroll.optDown.textOutOffset;\r\n      },\r\n      onMoving: function (mescroll, rate, downHight) {\r\n        // 下拉过程中的回调,滑动过程一直在执行; rate下拉区域当前高度与指定距离的比值(inOffset: rate<1; outOffset: rate>=1); downHight当前下拉区域的高度\r\n        if (mescroll.downProgressDom) {\r\n          var progress = 360 * rate;\r\n          mescroll.downProgressDom.style.webkitTransform = 'rotate(' + progress + 'deg)';\r\n          mescroll.downProgressDom.style.transform = 'rotate(' + progress + 'deg)';\r\n        }\r\n      },\r\n      beforeLoading: function (mescroll, downwarp) {\r\n        // 准备触发下拉刷新的回调\r\n        return false; // 如果return true,将不触发showLoading和callback回调; 常用来完全自定义下拉刷新, 参考案例【淘宝 v6.8.0】\r\n      },\r\n      showLoading: function (mescroll) {\r\n        // 显示下拉刷新进度的回调\r\n        if (mescroll.downTipDom) mescroll.downTipDom.innerHTML = mescroll.optDown.textLoading;\r\n        if (mescroll.downProgressDom) mescroll.downProgressDom.classList.add('mescroll-rotate');\r\n      },\r\n      afterLoading: function (mescroll) {\r\n        // 准备结束下拉的回调. 返回结束下拉的延时执行时间,默认0ms; 常用于结束下拉之前再显示另外一小段动画,才去隐藏下拉刷新的场景, 参考案例【dotJump】\r\n        return 0\r\n      },\r\n      callback: function (mescroll) {\r\n        // 下拉刷新的回调;默认重置上拉加载列表为第一页\r\n        mescroll.resetUpScroll();\r\n      }\r\n    })\r\n  }\r\n\r\n  /* 配置参数:上拉加载 */\r\n  MeScroll.prototype.extendUpScroll = function (optUp) {\r\n    // 是否为PC端,如果是scrollbar端,默认自定义滚动条\r\n    var isPC = this.os.pc;\r\n    // 上拉加载的配置\r\n    MeScroll.extend(optUp, {\r\n      use: true, // 是否启用上拉加载; 默认true\r\n      auto: true, // 是否在初始化完毕之后自动执行上拉加载的回调; 默认true\r\n      isLock: false, // 是否锁定上拉加载,默认false;\r\n      isBoth: false, // 上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新;默认false,两者不可同时触发;\r\n      isBounce: true, // 是否允许ios的bounce回弹;默认true,允许; 如果设置为false,则除了mescroll, mescroll-touch, mescroll-touch-x, mescroll-touch-y能够接收touchmove事件,其他部分均无法滑动,能够有效禁止bounce\r\n      callback: null, // 上拉加载的回调;function(page,mescroll){ }\r\n      page: {\r\n        num: 0, // 当前页码,默认0,回调之前会加1,即callback(page)会从1开始\r\n        size: 10, // 每页数据的数量\r\n        time: null // 加载第一页数据服务器返回的时间; 防止用户翻页时,后台新增了数据从而导致下一页数据重复;\r\n      },\r\n      noMoreSize: 5, // 如果列表已无数据,可设置列表的总数量要大于等于5条才显示无更多数据;避免列表数据过少(比如只有一条数据),显示无更多数据会不好看\r\n      offset: 100, // 列表滚动到距离底部小于100px,即可触发上拉加载的回调\r\n      toTop: {\r\n        // 回到顶部按钮,需配置src才显示\r\n        warpId: null, // 父布局的id; 默认添加在body中\r\n        src: null, // 图片路径,默认null;\r\n        html: null, // html标签内容,默认null; 如果同时设置了src,则优先取src\r\n        offset: 1000, // 列表滚动多少距离才显示回到顶部按钮,默认1000\r\n        warpClass: 'mescroll-totop', // 按钮样式,参见mescroll.css\r\n        showClass: 'mescroll-fade-in', // 显示样式,参见mescroll.css\r\n        hideClass: 'mescroll-fade-out', // 隐藏样式,参见mescroll.css\r\n        fadeDuration: 0.5, // 回到顶部按钮的显示隐藏动画时长,默认0.5秒. (注意:showClass和hideClass设置的动画时长不会生效.)\r\n        duration: 300, // 回到顶部的动画时长,默认300ms\r\n        supportTap: false, // 如果您的运行环境支持tap,则可配置true;\r\n        btnClick: null // 点击按钮的回调; 小提示:如果在回调里return true,将不执行回到顶部的操作.\r\n      },\r\n      loadFull: {\r\n        use: false, // 列表数据过少,不足以滑动触发上拉加载,是否自动加载下一页,直到满屏或者无更多数据为止;默认false,因为可通过调高page.size避免这个情况\r\n        delay: 500 // 延时执行的毫秒数; 延时是为了保证列表数据或占位的图片都已初始化完成,且下拉刷新上拉加载中区域动画已执行完毕;\r\n      },\r\n      empty: {\r\n        // 列表第一页无任何数据时,显示的空提示布局; 需配置warpId或clearEmptyId才生效;\r\n        warpId: null, // 父布局的id; 如果此项有值,将不使用clearEmptyId的值;\r\n        customId: null, // 自定义空布局的id; 如果此项有值,将不使用empty所有配置;空布局的显示隐藏只控制customId元素的显示隐藏;用于完全自定义empty的场景\r\n        icon: null, // 图标路径\r\n        tip: '~ 空空如也 ~', // 提示\r\n        btntext: '', // 按钮\r\n        btnClick: null, // 点击按钮的回调\r\n        supportTap: false // 如果您的运行环境支持tap,则可配置true;\r\n      },\r\n      clearId: null, // 加载第一页时需清空数据的列表id; 如果此项有值,将不使用clearEmptyId的值;\r\n      clearEmptyId: null, // 相当于同时设置了clearId和empty.warpId; 简化写法;默认null; 注意vue中不能配置此项\r\n      hardwareClass: 'mescroll-hardware', // 硬件加速样式,使上拉动画流畅\r\n      warpId: null, // 可配置上拉加载的布局添加到指定id的div;默认不配置,默认添加到mescrollId\r\n      warpClass: 'mescroll-upwarp', // 上拉加载的布局容器样式\r\n      htmlLoading: '<p class=\"upwarp-progress mescroll-rotate\"></p><p class=\"upwarp-tip\">加载中..</p>', // 上拉加载中的布局\r\n      htmlNodata: '<p class=\"upwarp-nodata\">-- END --</p>', // 无数据的布局\r\n      inited: function (mescroll, upwarp) {\r\n        // 初始化完毕的回调,可缓存dom 比如 mescroll.upProgressDom = upwarp.getElementsByClassName(\"upwarp-progress\")[0];\r\n      },\r\n      showLoading: function (mescroll, upwarp) {\r\n        // 上拉加载中.. mescroll.upProgressDom.style.display = \"block\" 不通过此方式显示,因为ios快速滑动到底部,进度条会无法及时渲染\r\n        upwarp.innerHTML = mescroll.optUp.htmlLoading;\r\n      },\r\n      showNoMore: function (mescroll, upwarp) {\r\n        // 无更多数据\r\n        upwarp.innerHTML = mescroll.optUp.htmlNodata;\r\n      },\r\n      onScroll: null, // 列表滑动监听,默认null; 例如 onScroll: function(mescroll, y, isUp){ }; //y为列表当前滚动条的位置; isUp=true向上滑,isUp=false向下滑\r\n      scrollbar: {\r\n        use: isPC, // 默认只在PC端自定义滚动条样式\r\n        barClass: 'mescroll-bar'\r\n      },\r\n      lazyLoad: {\r\n        use: false, // 是否开启懒加载,默认false\r\n        attr: 'imgurl', // 网络图片地址的属性名 (图片加载成功会自动移除改属性): <img imgurl='网络图  src='占位图''/>\r\n        showClass: 'mescroll-lazy-in', // 显示样式,参见mescroll.css\r\n        delay: 500, // 列表滚动的过程中每500ms检查一次图片是否在可视区域,如果在可视区域则加载图片\r\n        offset: 200 // 超出可视区域200px的图片仍可触发懒加载,目的是提前加载部分图片\r\n      }\r\n    })\r\n  }\r\n\r\n  /* 配置参数 */\r\n  MeScroll.extend = function (userOption, defaultOption) {\r\n    if (!userOption) return defaultOption;\r\n    for (var key in defaultOption) {\r\n      if (userOption[key] == null) {\r\n        userOption[key] = defaultOption[key];\r\n      } else if (typeof userOption[key] === 'object') {\r\n        MeScroll.extend(userOption[key], defaultOption[key]); // 深度匹配\r\n      }\r\n    }\r\n    return userOption;\r\n  }\r\n\r\n  /* -------初始化下拉刷新------- */\r\n  MeScroll.prototype.initDownScroll = function () {\r\n    var me = this;\r\n\r\n    // 配置参数\r\n    me.optDown = me.options.down || {};\r\n\r\n    // 具体参数配置\r\n    me.extendDownScroll(me.optDown);\r\n\r\n    // 鼠标或手指的按下事件\r\n    me.touchstartEvent = function (e) {\r\n      if (me.isScrollTo) me.preventDefault(e); // 如果列表执行滑动事件,则阻止事件,优先执行scrollTo方法\r\n\r\n      me.startPoint = me.getPoint(e); // 记录起点\r\n      me.lastPoint = me.startPoint; // 重置上次move的点\r\n\r\n      me.maxTouchmoveY = me.getBodyHeight() - me.optDown.bottomOffset; // 手指触摸的最大范围(写在touchstart避免body获取高度为0的情况)\r\n      me.inTouchend = false; // 标记不是touchend\r\n      var scrollTop = me.getScrollTop();// 滚动条的位置\r\n      me.isKeepTop = scrollTop === 0; // 标记滚动条起点为0\r\n      if (me.os.pc && scrollTop <= 0) {\r\n        // 在顶部给PC端添加move事件\r\n        me.scrollDom.addEventListener('mousemove', me.touchmoveEvent, {\r\n          passive: false\r\n        });\r\n        document.ondragstart = function () { // 在顶部禁止PC端拖拽图片,避免与下拉刷新冲突\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    me.scrollDom.addEventListener('mousedown', me.touchstartEvent); // PC端鼠标事件\r\n    me.scrollDom.addEventListener('touchstart', me.touchstartEvent); // 移动端手指事件\r\n\r\n    // 鼠标或手指的滑动事件\r\n    me.touchmoveEvent = function (e) {\r\n      if (!me.startPoint) return;\r\n\r\n      var scrollTop = me.getScrollTop(); // 当前滚动条的距离\r\n      if (scrollTop > 0) me.isKeepTop = false; // 在移动过程中,只要滚动条有一次大于0,则标记false\r\n      var curPoint = me.getPoint(e); // 当前点\r\n\r\n      var moveY = curPoint.y - me.startPoint.y; // 和起点比,移动的距离,大于0向下拉,小于0向上拉\r\n\r\n      // 向下拉\r\n      if (moveY > 0) {\r\n        // 在顶部\r\n        if (scrollTop <= 0) {\r\n          me.preventDefault(e); // 阻止浏览器默认的滚动,避免触发bounce\r\n\r\n          // 可下拉的条件\r\n          if (me.optDown.use && !me.inTouchend && !me.isDownScrolling && !me.optDown.isLock && (!me.isUpScrolling || (me.isUpScrolling && me.optUp.isBoth))) {\r\n            if (me.optDown.mustToTop && !me.isKeepTop) return; // 是否配置了必须在顶部才可以下拉\r\n\r\n            // 下拉的角度是否在配置的范围内\r\n            var x = Math.abs(me.lastPoint.x - curPoint.x);\r\n            var y = Math.abs(me.lastPoint.y - curPoint.y);\r\n            var z = Math.sqrt(x * x + y * y);\r\n            if (z !== 0) {\r\n              var angle = Math.asin(y / z) / Math.PI * 180; // 两点之间的角度,区间 [0,90]\r\n              if (angle < me.optDown.minAngle) return; // 如果小于配置的角度,则不往下执行下拉刷新\r\n            }\r\n\t\t\t\t\t\t\r\n            // 如果手指的位置超过配置的距离,则提前结束下拉,避免Webview嵌套导致touchend无法触发\r\n            if (me.maxTouchmoveY > 0 && curPoint.y >= me.maxTouchmoveY) {\r\n              me.inTouchend = true; // 标记执行touchend\r\n              me.touchendEvent(); // 提前触发touchend\r\n              return;\r\n            }\r\n\r\n            var diff = curPoint.y - me.lastPoint.y; // 和上次比,移动的距离 (大于0向下,小于0向上)\r\n            if (!me.downHight) me.downHight = 0; // 下拉区域的高度\r\n            // 下拉距离  < 指定距离\r\n            if (me.downHight < me.optDown.offset) {\r\n              if (me.movetype !== 1) {\r\n                me.movetype = 1; // 加入标记,保证只执行一次\r\n                me.optDown.inOffset(me); // 进入指定距离范围内那一刻的回调,只执行一次\r\n                me.downwarp.classList.remove(me.optDown.resetClass); // 移除高度重置的动画\r\n                me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\r\n                if (me.os.ios && !me.isKeepTop) { // 下拉过程中,滚动条一直在顶部的,则不必取消回弹,否则会闪白屏\r\n                  me.scrollDom.classList.add(me.optDown.hardwareClass); // 开启硬件加速,解决iOS下拉因隐藏进度条而闪屏的问题\r\n                  me.scrollDom.style.webkitOverflowScrolling = 'auto'; // 取消列表回弹效果,避免与下面me.downwarp.style.height混合,而导致界面抖动闪屏\r\n                  me.isSetScrollAuto = true; // 标记设置了webkitOverflowScrolling为auto\r\n                }\r\n              }\r\n              me.downHight += diff * me.optDown.inOffsetRate; // 越往下,高度变化越小\r\n\r\n              // 指定距离  <= 下拉距离\r\n            } else {\r\n              if (me.movetype !== 2) {\r\n                me.movetype = 2; // 加入标记,保证只执行一次\r\n                me.optDown.outOffset(me); // 下拉超过指定距离那一刻的回调,只执行一次\r\n                me.downwarp.classList.remove(me.optDown.resetClass); // 移除高度重置的动画\r\n                me.isMoveDown = true; // 标记下拉区域高度改变,在touchend重置回来\r\n                if (me.os.ios && !me.isKeepTop) { // 下拉过程中,滚动条一直在顶部的,则不必取消回弹,否则会闪白屏\r\n                  me.scrollDom.classList.add(me.optDown.hardwareClass); // 开启硬件加速,解决iOS下拉因隐藏进度条而闪屏的问题\r\n                  me.scrollDom.style.webkitOverflowScrolling = 'auto'; // 取消列表回弹效果,避免与下面me.downwarp.style.height混合,而导致界面抖动闪屏\r\n                  me.isSetScrollAuto = true; // 标记设置了webkitOverflowScrolling为auto\r\n                }\r\n              }\r\n              if (diff > 0) { // 向下拉\r\n                me.downHight += diff * me.optDown.outOffsetRate; // 越往下,高度变化越小\r\n              } else { // 向上收\r\n                me.downHight += diff; // 向上收回高度,则向上滑多少收多少高度\r\n              }\r\n            }\r\n\r\n            me.downwarp.style.height = me.downHight + 'px'; // 实时更新下拉区域高度\r\n            var rate = me.downHight / me.optDown.offset; // 下拉区域当前高度与指定距离的比值\r\n            me.optDown.onMoving(me, rate, me.downHight); // 下拉过程中的回调,一直在执行\r\n          }\r\n        }\r\n\r\n        // 向上拉\r\n      } else if (moveY < 0) {\r\n        var scrollHeight = me.getScrollHeight(); // 滚动内容的高度\r\n        var clientHeight = me.getClientHeight(); // 滚动容器的高度\r\n        var toBottom = scrollHeight - clientHeight - scrollTop; // 滚动条距离底部的距离\r\n\r\n        // 如果在底部,则阻止浏览器默认事件\r\n        if (!me.optUp.isBounce && toBottom <= 0) me.preventDefault(e);\r\n\r\n        // 如果不满屏或者已经在底部,无法触发scroll事件,此时需主动触发上拉回调\r\n        if (me.optUp.use && !me.optUp.isLock && me.optUp.hasNext && !me.isUpScrolling && (!me.isDownScrolling || (me.isDownScrolling && me.optDown.isBoth)) && (clientHeight + me.optUp.offset >= scrollHeight || toBottom <= 0)) {\r\n          me.triggerUpScroll();\r\n        }\r\n      }\r\n\r\n      me.lastPoint = curPoint; // 记录本次移动的点\r\n    }\r\n\r\n    // 移动端手指的滑动事件\r\n    me.scrollDom.addEventListener('touchmove', me.touchmoveEvent, {\r\n      passive: false\r\n    });\r\n\r\n    // 鼠标或手指的离开事件\r\n    me.touchendEvent = function () {\r\n      // 如果下拉区域高度已改变,则需重置回来\r\n      if (me.optDown.use && me.isMoveDown) {\r\n        if (me.downHight >= me.optDown.offset) {\r\n          // 符合触发刷新的条件\r\n          me.triggerDownScroll();\r\n        } else {\r\n          // 不符合的话 则重置\r\n          me.downwarp.classList.add(me.optDown.resetClass); // 加入高度重置的动画,过渡平滑\r\n          me.downHight = 0;\r\n          me.downwarp.style.height = 0;\r\n        }\r\n        if (me.isSetScrollAuto) {\r\n          me.scrollDom.style.webkitOverflowScrolling = 'touch';\r\n          me.scrollDom.classList.remove(me.optDown.hardwareClass);\r\n          me.isSetScrollAuto = false;\r\n        }\r\n        me.movetype = 0;\r\n        me.isMoveDown = false;\r\n      }\r\n\r\n      if (me.os.pc) {\r\n        me.scrollDom.removeEventListener('mousemove', me.touchmoveEvent); // 移除pc端的move事件\r\n        document.ondragstart = function () { // 解除PC端禁止拖拽图片\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    me.scrollDom.addEventListener('mouseup', me.touchendEvent); // PC端鼠标抬起事件\r\n    me.scrollDom.addEventListener('mouseleave', me.touchendEvent); // PC端鼠标离开事件\r\n    me.scrollDom.addEventListener('touchend', me.touchendEvent); // 移动端手指事件\r\n    me.scrollDom.addEventListener('touchcancel', me.touchendEvent); // 移动端系统停止跟踪触摸\r\n\r\n    // 在页面中加入下拉布局\r\n    if (me.optDown.use) {\r\n      me.downwarp = document.createElement('div');\r\n      me.downwarp.className = me.optDown.warpClass;\r\n      me.downwarp.innerHTML = '<div class=\"downwarp-content\">' + me.optDown.htmlContent + '</div>';\r\n      var downparent = me.optDown.warpId ? me.getDomById(me.optDown.warpId) : me.scrollDom;\r\n      if (me.optDown.warpId && downparent) {\r\n        downparent.appendChild(me.downwarp);\r\n      } else {\r\n        if (!downparent) downparent = me.scrollDom;\r\n        downparent.insertBefore(me.downwarp, me.scrollDom.firstChild);\r\n      }\r\n      // 初始化完毕的回调\r\n      setTimeout(function () { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\r\n        me.optDown.inited(me, me.downwarp);\r\n      }, 0)\r\n    }\r\n  }\r\n\r\n  /* 阻止浏览器默认滚动事件 */\r\n  MeScroll.prototype.preventDefault = function (e) {\r\n    // cancelable:是否可以被禁用; defaultPrevented:是否已经被禁用\r\n    if (e && e.cancelable && !e.defaultPrevented) e.preventDefault()\r\n  }\r\n\r\n  /* 根据点击滑动事件获取第一个手指的坐标 */\r\n  MeScroll.prototype.getPoint = function (e) {\r\n    return {\r\n      x: e.touches ? e.touches[0].pageX : e.clientX,\r\n      y: e.touches ? e.touches[0].pageY : e.clientY\r\n    }\r\n  }\r\n\r\n  /* 触发下拉刷新 */\r\n  MeScroll.prototype.triggerDownScroll = function () {\r\n    if (!this.optDown.beforeLoading(this, this.downwarp)) { // 准备触发下拉的回调,return true则处于完全自定义状态;默认return false;\r\n      this.showDownScroll(); // 下拉刷新中...\r\n      this.optDown.callback && this.optDown.callback(this); // 执行回调,联网加载数据\r\n    }\r\n  }\r\n\r\n  /* 显示下拉进度布局 */\r\n  MeScroll.prototype.showDownScroll = function () {\r\n    this.isDownScrolling = true; // 标记下拉中\r\n    this.optDown.showLoading(this); // 下拉刷新中...\r\n    this.downHight = this.optDown.offset; // 更新下拉区域高度\r\n    this.downwarp.classList.add(this.optDown.resetClass); // 加入高度重置的动画,过渡平滑\r\n    this.downwarp.style.height = this.optDown.offset + 'px'; // 调整下拉区域高度\r\n  }\r\n\r\n  /* 结束下拉刷新 */\r\n  MeScroll.prototype.endDownScroll = function () {\r\n    var me = this;\r\n    // 结束下拉刷新的方法\r\n    var endScroll = function () {\r\n      me.downHight = 0;\r\n      me.downwarp.style.height = 0;\r\n      me.isDownScrolling = false;\r\n      if (me.downProgressDom) me.downProgressDom.classList.remove('mescroll-rotate');\r\n    }\r\n    // 结束下拉刷新时的回调\r\n    var delay = me.optDown.afterLoading(me); // 结束下拉刷新的延时,单位ms\r\n    if (typeof delay === 'number' && delay > 0) {\r\n      setTimeout(endScroll, delay);\r\n    } else {\r\n      endScroll();\r\n    }\r\n  }\r\n\r\n  /* 锁定下拉刷新:isLock=ture,null锁定;isLock=false解锁 */\r\n  MeScroll.prototype.lockDownScroll = function (isLock) {\r\n    if (isLock == null) isLock = true;\r\n    this.optDown.isLock = isLock;\r\n  }\r\n\r\n  /* -------初始化上拉加载------- */\r\n  MeScroll.prototype.initUpScroll = function () {\r\n    var me = this;\r\n\r\n    // 配置参数\r\n    me.optUp = me.options.up || {\r\n      use: false\r\n    };\r\n\r\n    // 具体参数配置\r\n    me.extendUpScroll(me.optUp);\r\n\r\n    // 自定义滚动条 (默认只在PC端设置)\r\n    if (me.optUp.scrollbar.use) me.scrollDom.classList.add(me.optUp.scrollbar.barClass);\r\n\r\n    // 不允许ios的bounce时,需禁止webview的touchmove事件\r\n    if (!me.optUp.isBounce) me.setBounce(false);\r\n\r\n    if (me.optUp.use === false) return; // 配置不使用上拉加载时,则不初始化上拉布局\r\n    me.optUp.hasNext = true; // 如果使用上拉,则默认有下一页\r\n\r\n    // 在页面中加入上拉布局\r\n    me.upwarp = document.createElement('div');\r\n    me.upwarp.className = me.optUp.warpClass;\r\n    var upparent;\r\n    if (me.optUp.warpId) upparent = me.getDomById(me.optUp.warpId);\r\n    if (!upparent) upparent = me.scrollDom;\r\n    upparent.appendChild(me.upwarp);\r\n\r\n    // 滚动监听\r\n    me.preScrollY = 0;\r\n    me.lazyStartTime = new Date().getTime();// 懒加载的初始间隔时间\r\n    me.lazyTag = 'mescroll-lazying';// 懒加载时,图片正在加载的标记\r\n    me.scrollEvent = function () {\r\n      // 列表内容顶部卷去的高度(含列表边框)\r\n      var scrollTop = me.getScrollTop();\r\n\r\n      // 向上滑还是向下滑动\r\n      var isUp = scrollTop - me.preScrollY > 0;\r\n      me.preScrollY = scrollTop;\r\n\r\n      // 如果没有在加载中\r\n      if (!me.isUpScrolling && (!me.isDownScrolling || (me.isDownScrolling && me.optDown.isBoth))) {\r\n        // offsetHeight 列表高度(内容+内边距+边框),滚动条在边框之内,所以使用clientHeight即可\r\n        // clientHeight 列表高度(内容+内边距),不含列表边框\r\n        // scrollHeight 列表内容撑开的高度\r\n        if (!me.optUp.isLock && me.optUp.hasNext) {\r\n          var toBottom = me.getScrollHeight() - me.getClientHeight() - scrollTop; // 滚动条距离底部的距离\r\n          if (toBottom <= me.optUp.offset && isUp) {\r\n            // 如果滚动条距离底部指定范围内且向上滑,则执行上拉加载回调\r\n            me.triggerUpScroll();\r\n          }\r\n        }\r\n      }\r\n\r\n      // 顶部按钮的显示隐藏\r\n      var optTop = me.optUp.toTop;\r\n      if (optTop.src || optTop.html) {\r\n        if (scrollTop >= optTop.offset) {\r\n          me.showTopBtn();\r\n        } else {\r\n          me.hideTopBtn();\r\n        }\r\n      }\r\n\r\n      // 懒加载\r\n      if (me.optUp.lazyLoad.use) {\r\n        // 节流:限制触发时间间隔\r\n        var curTime = new Date().getTime();\r\n        me.lazyTimer && clearTimeout(me.lazyTimer);\r\n        if (curTime - me.lazyStartTime >= me.optUp.lazyLoad.delay) {\r\n          me.lazyStartTime = curTime;\r\n          me.lazyLoad(0);// 列表刚滚动的时候,懒加载一次\r\n        } else {\r\n          me.lazyTimer = me.lazyLoad();\r\n        }\r\n      }\r\n\r\n      // 滑动监听\r\n      me.optUp.onScroll && me.optUp.onScroll(me, scrollTop, isUp);\r\n    }\r\n\r\n    if (me.isScrollBody) {\r\n      window.addEventListener('scroll', me.scrollEvent);\r\n    } else {\r\n      me.scrollDom.addEventListener('scroll', me.scrollEvent);\r\n    }\r\n\r\n    // 初始化完毕的回调\r\n    setTimeout(function () { // 待主线程执行完毕再执行,避免new MeScroll未初始化,在回调获取不到mescroll的实例\r\n      me.optUp.inited(me, me.upwarp);\r\n    }, 0)\r\n  }\r\n\r\n  /* 是否允许ios的Bounce; true或null为允许; false禁止bounce */\r\n  MeScroll.prototype.setBounce = function (isBounce) {\r\n    if (this.isScrollBody || !this.os.ios) return; // 不支持body为滚动区域和非ios设备\r\n    if (isBounce === false) {\r\n      this.optUp.isBounce = false; // 禁止\r\n      window.addEventListener('touchmove', this.bounceTouchmove, {\r\n        passive: false\r\n      });\r\n    } else {\r\n      this.optUp.isBounce = true; // 允许\r\n      window.removeEventListener('touchmove', this.bounceTouchmove);\r\n    }\r\n  }\r\n\r\n  /* 处理bounce的touchmove事件 */\r\n  MeScroll.prototype.bounceTouchmove = function (e) {\r\n    var me = this;\r\n    var el = e.target;\r\n    // 当前touch的元素及父元素是否要拦截touchmove事件\r\n    var isPrevent = true;\r\n    while (el !== document.body && el !== document) {\r\n      var cls = el.classList;\r\n      if (cls) {\r\n        if (cls.contains('mescroll') || cls.contains('mescroll-touch')) {\r\n          isPrevent = false; // 如果是指定条件的元素,则无需拦截touchmove事件\r\n          break;\r\n        } else if (cls.contains('mescroll-touch-x') || cls.contains('mescroll-touch-y')) {\r\n          // 如果配置了水平或者垂直滑动\r\n          var curX = e.touches ? e.touches[0].pageX : e.clientX; // 当前第一个手指距离列表顶部的距离x\r\n          var curY = e.touches ? e.touches[0].pageY : e.clientY; // 当前第一个手指距离列表顶部的距离y\r\n\r\n          if (!me.preWinX) me.preWinX = curX; // 设置上次移动的距离x\r\n          if (!me.preWinY) me.preWinY = curY; // 设置上次移动的距离y\r\n\r\n          // 计算两点之间的角度\r\n          var x = Math.abs(me.preWinX - curX);\r\n          var y = Math.abs(me.preWinY - curY);\r\n          var z = Math.sqrt(x * x + y * y);\r\n\r\n          me.preWinX = curX; // 记录本次curX的值\r\n          me.preWinY = curY; // 记录本次curY的值\r\n\r\n          if (z !== 0) {\r\n            var angle = Math.asin(y / z) / Math.PI * 180; // 角度区间 [0,90]\r\n            if ((angle <= 45 && cls.contains('mescroll-touch-x')) || (angle > 45 && cls.contains('mescroll-touch-y'))) {\r\n              isPrevent = false; // 水平滑动或者垂直滑动,不拦截touchmove事件\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      el = el.parentNode; // 继续检查其父元素\r\n    }\r\n\r\n    // 拦截touchmove事件:是否可以被禁用&&是否已经被禁用 (这里不使用me.preventDefault(e)的方法,因为某些情况下会报找不到方法的异常)\r\n    if (isPrevent && e.cancelable && !e.defaultPrevented && typeof e.preventDefault === \"function\") e.preventDefault();\r\n  }\r\n\r\n  /* 触发上拉加载 */\r\n  MeScroll.prototype.triggerUpScroll = function () {\r\n    if (this.optUp.callback && !this.isUpScrolling) {\r\n      this.showUpScroll(); // 上拉加载中...\r\n      this.optUp.page.num++; // 预先加一页,如果失败则减回\r\n      this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\r\n      this.optUp.callback(this.optUp.page, this); // 执行回调,联网加载数据\r\n    }\r\n  }\r\n\r\n  /* 显示上拉加载中 */\r\n  MeScroll.prototype.showUpScroll = function () {\r\n    this.isUpScrolling = true; // 标记上拉加载中\r\n    this.upwarp.classList.add(this.optUp.hardwareClass); // 添加硬件加速样式,使动画更流畅\r\n    this.upwarp.style.visibility = 'visible'; // 显示上拉加载区域\r\n    this.upwarp.style.display = 'block'; // 显示上拉加载区域\r\n    this.optUp.showLoading(this, this.upwarp); // 加载中...\r\n  }\r\n\r\n  /* 显示上拉无更多数据 */\r\n  MeScroll.prototype.showNoMore = function () {\r\n    this.upwarp.style.visibility = 'visible'; // 显示上拉加载区域\r\n    this.upwarp.style.display = 'block'; // 显示上拉加载区域\r\n    this.optUp.hasNext = false; // 无更多数据\r\n    this.optUp.showNoMore(this, this.upwarp); // 无更多数据\r\n  }\r\n\r\n  /* 隐藏上拉区域. displayAble: 是否通过display:none隐藏, 默认false通过visibility:hidden的方式隐藏**/\r\n  MeScroll.prototype.hideUpScroll = function (displayAble) {\r\n    if (displayAble) {\r\n      this.upwarp.style.display = 'none'; // 通过display:none隐藏: 优点隐藏后不占位,缺点列表快速滑动到底部不能及时显示加载中\r\n    } else {\r\n      this.upwarp.style.visibility = 'hidden'; // 通过visibility:hidden的方式隐藏,优点当列表快速滑动到底部能及时显示加载中,缺点隐藏后会占位\r\n    }\r\n    this.upwarp.classList.remove(this.optUp.hardwareClass); // 移除硬件加速样式\r\n    var upProgressDom = this.upwarp.getElementsByClassName('upwarp-progress')[0];\r\n    if (upProgressDom) upProgressDom.classList.remove('mescroll-rotate');\r\n  }\r\n\r\n  /* 结束上拉加载 */\r\n  MeScroll.prototype.endUpScroll = function (isShowNoMore, displayAble) {\r\n    if (isShowNoMore != null) { // isShowNoMore=null,不处理下拉状态,下拉刷新的时候调用\r\n      if (isShowNoMore) {\r\n        this.showNoMore(); // isShowNoMore=true,显示无更多数据\r\n      } else {\r\n        this.hideUpScroll(displayAble); // isShowNoMore=false,隐藏上拉加载\r\n      }\r\n    }\r\n    this.isUpScrolling = false; // 标记结束上拉加载\r\n  }\r\n\r\n  /* 重置上拉加载列表为第一页\r\n     *isShowLoading 是否显示进度布局;\r\n     * 1.默认null,不传参,则显示上拉加载的进度布局\r\n     * 2.传参true, 则显示下拉刷新的进度布局\r\n     * 3.传参false,则不显示上拉和下拉的进度 (常用于静默更新列表数据)\r\n     */\r\n  MeScroll.prototype.resetUpScroll = function (isShowLoading) {\r\n    if (this.optUp && this.optUp.use) {\r\n      var page = this.optUp.page;\r\n      this.prePageNum = page.num; // 缓存重置前的页码,加载失败可退回\r\n      this.prePageTime = page.time; // 缓存重置前的时间,加载失败可退回\r\n      page.num = 1; // 重置为第一页\r\n      page.time = null; // 重置时间为空\r\n      if (!this.isDownScrolling && isShowLoading !== false) { // 如果不是下拉刷新触发的resetUpScroll并且不配置列表静默更新,则显示进度;\r\n        if (isShowLoading == null) {\r\n          this.removeEmpty(); // 移除空布局\r\n          this.clearDataList(); // 先清空列表数据,才能显示到上拉加载的布局\r\n          this.showUpScroll(); // 不传参,默认显示上拉加载的进度布局\r\n        } else {\r\n          this.showDownScroll(); // 传true,显示下拉刷新的进度布局,不清空列表\r\n        }\r\n      }\r\n      this.isUpAutoLoad = true; // 标记上拉已经自动执行过,避免初始化时多次触发上拉回调\r\n      this.optUp.callback && this.optUp.callback(page, this); // 执行上拉回调\r\n    }\r\n  }\r\n\r\n  /* 设置page.num的值 */\r\n  MeScroll.prototype.setPageNum = function (num) {\r\n    this.optUp.page.num = num - 1;\r\n  }\r\n\r\n  /* 设置page.size的值 */\r\n  MeScroll.prototype.setPageSize = function (size) {\r\n    this.optUp.page.size = size;\r\n  }\r\n\r\n  /* 清空上拉加载的数据列表 */\r\n  MeScroll.prototype.clearDataList = function () {\r\n    var listId = this.optUp.clearId || this.optUp.clearEmptyId; // 优先使用clearId\r\n    if (listId) {\r\n      var listDom = this.getDomById(listId);\r\n      if (listDom) listDom.innerHTML = '';\r\n    }\r\n  }\r\n\r\n  /* 联网回调成功,结束下拉刷新和上拉加载\r\n     * dataSize: 当前页的数据量(必传)\r\n     * totalPage: 总页数(必传)\r\n     * systime: 服务器时间 (可空)\r\n     */\r\n  MeScroll.prototype.endByPage = function (dataSize, totalPage, systime) {\r\n    var hasNext;\r\n    if (this.optUp.use && totalPage != null) hasNext = this.optUp.page.num < totalPage; // 是否还有下一页\r\n    this.endSuccess(dataSize, hasNext, systime);\r\n  }\r\n\r\n  /* 联网回调成功,结束下拉刷新和上拉加载\r\n     * dataSize: 当前页的数据量(必传)\r\n     * totalSize: 列表所有数据总数量(必传)\r\n     * systime: 服务器时间 (可空)\r\n     */\r\n  MeScroll.prototype.endBySize = function (dataSize, totalSize, systime) {\r\n    var hasNext;\r\n    if (this.optUp.use && totalSize != null) {\r\n      var loadSize = (this.optUp.page.num - 1) * this.optUp.page.size + dataSize; // 已加载的数据总数\r\n      hasNext = loadSize < totalSize; // 是否还有下一页\r\n    }\r\n    this.endSuccess(dataSize, hasNext, systime);\r\n  }\r\n\r\n  /* 联网回调成功,结束下拉刷新和上拉加载\r\n     * dataSize: 当前页的数据个数(不是所有页的数据总和),用于上拉加载判断是否还有下一页.如果不传,则会判断还有下一页\r\n     * hasNext: 是否还有下一页,布尔类型;用来解决这个小问题:比如列表共有20条数据,每页加载10条,共2页.如果只根据dataSize判断,则需翻到第三页才会知道无更多数据,如果传了hasNext,则翻到第二页即可显示无更多数据.\r\n     * systime: 服务器时间(可空);用来解决这个小问题:当准备翻下一页时,数据库新增了几条记录,此时翻下一页,前面的几条数据会和上一页的重复;这里传入了systime,那么upCallback的page.time就会有值,把page.time传给服务器,让后台过滤新加入的那几条记录\r\n     */\r\n  MeScroll.prototype.endSuccess = function (dataSize, hasNext, systime) {\r\n    var me = this;\r\n    // 结束下拉刷新\r\n    if (me.isDownScrolling) me.endDownScroll();\r\n\r\n    // 结束上拉加载\r\n    if (me.optUp.use) {\r\n      var isShowNoMore; // 是否已无更多数据\r\n      if (dataSize != null) {\r\n        var pageNum = me.optUp.page.num; // 当前页码\r\n        var pageSize = me.optUp.page.size; // 每页长度\r\n        // 如果是第一页\r\n        if (pageNum === 1) {\r\n          me.clearDataList(); // 自动清空第一页列表数据\r\n          if (systime) me.optUp.page.time = systime; // 设置加载列表数据第一页的时间\r\n        }\r\n        if (dataSize < pageSize || hasNext === false) {\r\n          // 返回的数据不满一页时,则说明已无更多数据\r\n          me.optUp.hasNext = false;\r\n          if (dataSize === 0 && pageNum === 1) {\r\n            // 如果第一页无任何数据且配置了空布局\r\n            isShowNoMore = false;\r\n            me.showEmpty();\r\n          } else {\r\n            // 总列表数少于配置的数量,则不显示无更多数据\r\n            var allDataSize = (pageNum - 1) * pageSize + dataSize;\r\n            if (allDataSize < me.optUp.noMoreSize) {\r\n              isShowNoMore = false;\r\n            } else {\r\n              isShowNoMore = true;\r\n            }\r\n            me.removeEmpty(); // 移除空布局\r\n          }\r\n        } else {\r\n          // 还有下一页\r\n          isShowNoMore = false;\r\n          me.optUp.hasNext = true;\r\n          me.removeEmpty(); // 移除空布局\r\n        }\r\n      }\r\n\r\n      // 隐藏上拉\r\n      var displayAble = !me.optUp.hasNext; // 没有下一页且少于noMoreSize,则以display:none的方式隐藏上拉布局\r\n      me.endUpScroll(isShowNoMore, displayAble);\r\n\r\n      // 检查是否满屏自动加载下一页\r\n      me.loadFull();\r\n\r\n      // 懒加载\r\n      me.optUp.lazyLoad.use && me.lazyLoad(20);\r\n    }\r\n  }\r\n\r\n  /* 回调失败,结束下拉刷新和上拉加载 */\r\n  MeScroll.prototype.endErr = function () {\r\n    // 结束下拉,回调失败重置回原来的页码和时间\r\n    if (this.isDownScrolling) {\r\n      var page = this.optUp.page;\r\n      if (page && this.prePageNum) {\r\n        page.num = this.prePageNum;\r\n        page.time = this.prePageTime;\r\n      }\r\n      this.endDownScroll();\r\n    }\r\n    // 结束上拉,回调失败重置回原来的页码\r\n    if (this.isUpScrolling) {\r\n      this.optUp.page.num--;\r\n      this.endUpScroll(false);\r\n    }\r\n  }\r\n\r\n  /* 检查如果加载的数据过少,无法触发上拉加载时,则自动加载下一页,直到满屏或者没有更多数据\r\n     此方法最好在列表的数据加载完成之后调用,以便计算列表内容高度的准确性 */\r\n  MeScroll.prototype.loadFull = function () {\r\n    var me = this;\r\n    if (me.optUp.loadFull.use && !me.optUp.isLock && me.optUp.hasNext && me.optUp.callback && me.getScrollHeight() <= me.getClientHeight()) {\r\n      setTimeout(function () {\r\n        // 延时之后,还需再判断一下高度,因为可能有些图片在延时期间加载完毕撑开高度\r\n        if (me.getScrollHeight() <= me.getClientHeight()) me.triggerUpScroll();\r\n      }, me.optUp.loadFull.delay)\r\n    }\r\n  }\r\n\r\n  /* 锁定上拉加载:isLock=ture,null锁定;isLock=false解锁 */\r\n  MeScroll.prototype.lockUpScroll = function (isLock) {\r\n    if (isLock == null) isLock = true;\r\n    this.optUp.isLock = isLock;\r\n  }\r\n\r\n  /* --------无任何数据的空布局-------- */\r\n  MeScroll.prototype.showEmpty = function () {\r\n    var me = this;\r\n    var optEmpty = me.optUp.empty; // 空布局的配置\r\n    if (optEmpty.customId) {\r\n\t  // 如果是显示自定义内容 && 该customId元素存在\r\n      me.emptyDom = me.getDomById(optEmpty.customId);\r\n\t  if(me.emptyDom){\r\n\t\tme.emptyDom.style.display = 'block';\r\n\t\treturn;\r\n\t  }\r\n    }\r\n    var warpId = optEmpty.warpId || me.optUp.clearEmptyId; // 优先使用warpId\r\n    if (warpId == null) return;\r\n    var emptyWarp = me.getDomById(warpId) // 要显示空布局的位置\r\n    if (emptyWarp) {\r\n      me.removeEmpty(); // 先移除,避免重复加入\r\n      // 初始化无任何数据的空布局\r\n      var str = '';\r\n      if (optEmpty.icon) str += '<img class=\"empty-icon\" src=\"' + optEmpty.icon + '\"/>'; // 图标\r\n      if (optEmpty.tip) str += '<p class=\"empty-tip\">' + optEmpty.tip + '</p>'; // 提示\r\n      if (optEmpty.btntext) str += '<p class=\"empty-btn\">' + optEmpty.btntext + '</p>'; // 按钮\r\n      me.emptyDom = document.createElement('div');\r\n      me.emptyDom.className = 'mescroll-empty';\r\n      me.emptyDom.innerHTML = str;\r\n      emptyWarp.appendChild(me.emptyDom);\r\n      if (optEmpty.btnClick) { // 点击按钮的回调\r\n        var emptyBtn = me.emptyDom.getElementsByClassName('empty-btn')[0];\r\n        if (optEmpty.supportTap) {\r\n          emptyBtn.addEventListener('tap', function (e) {\r\n            e.stopPropagation();\r\n            me.preventDefault(e)\r\n            optEmpty.btnClick();\r\n          })\r\n        } else {\r\n          emptyBtn.onclick = function () {\r\n            optEmpty.btnClick();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /* 移除空布局 */\r\n  MeScroll.prototype.removeEmpty = function () {\r\n\tif (this.optUp.empty.customId && this.emptyDom) {\r\n      this.emptyDom.style.display = 'none' // 隐藏自定义空布局\r\n    } else {\r\n      this.removeChild(this.emptyDom);\r\n    }\r\n  }\r\n\r\n  /* --------回到顶部的按钮-------- */\r\n  MeScroll.prototype.showTopBtn = function (fadeDuration) {\r\n    if (!this.topBtnShow) {\r\n      this.topBtnShow = true; // 标记显示\r\n      var me = this;\r\n      var optTop = me.optUp.toTop; // 回到顶部的配置\r\n      if (me.toTopBtn == null) {\r\n        // 未加入按钮,则加入\r\n        if (optTop.html) {\r\n          me.toTopBtn = document.createElement('div');\r\n          me.toTopBtn.innerHTML = optTop.html;\r\n        } else {\r\n          me.toTopBtn = document.createElement('img');\r\n          me.toTopBtn.src = optTop.src;\r\n        }\r\n        me.toTopBtn.className = optTop.warpClass;\r\n        if (optTop.supportTap) {\r\n          me.toTopBtn.addEventListener('tap', function (e) {\r\n            e.stopPropagation();\r\n            me.preventDefault(e);\r\n            var disToTop = optTop.btnClick && optTop.btnClick(); // 执行回调\r\n            if (disToTop !== true) { // 如果回调里return true,将不执行回到顶部操作\r\n              me.scrollTo(0, me.optUp.toTop.duration); // 置顶\r\n            }\r\n          })\r\n        } else {\r\n          me.toTopBtn.onclick = function () {\r\n            var disToTop = optTop.btnClick && optTop.btnClick(); // 执行回调\r\n            if (disToTop !== true) { // 如果回调里return true,将不执行回到顶部操作\r\n              me.scrollTo(0, me.optUp.toTop.duration); // 置顶\r\n            }\r\n          }\r\n        }\r\n        var warpDom; // 是否配置父布局\r\n        if (optTop.warpId) warpDom = me.getDomById(optTop.warpId);\r\n        if (!warpDom) warpDom = document.body;\r\n        warpDom.appendChild(me.toTopBtn);\r\n      }\r\n      // 显示--淡入动画\r\n      me.toTopBtn.classList.remove(optTop.hideClass);\r\n      me.toTopBtn.classList.add(optTop.showClass);\r\n      me.setTopBtnFadeDuration(fadeDuration);\r\n    }\r\n  }\r\n  /* 隐藏回到顶部的按钮 */\r\n  MeScroll.prototype.hideTopBtn = function (fadeDuration) {\r\n    if (this.topBtnShow && this.toTopBtn) {\r\n      this.topBtnShow = false;\r\n      this.toTopBtn.classList.remove(this.optUp.toTop.showClass);\r\n      this.toTopBtn.classList.add(this.optUp.toTop.hideClass);\r\n      this.setTopBtnFadeDuration(fadeDuration);\r\n    }\r\n  }\r\n  /* 设置回到顶部按钮的显示隐藏动画时长,默认0.5秒 */\r\n  MeScroll.prototype.setTopBtnFadeDuration = function (fadeDuration) {\r\n    if (this.toTopBtn) {\r\n      var duration = (fadeDuration != null ? fadeDuration : this.optUp.toTop.fadeDuration) + 's';\r\n      this.toTopBtn.style.animationDuration = duration;\r\n      this.toTopBtn.style.webkitAnimationDuration = duration;\r\n    }\r\n  }\r\n\r\n  /* 滑动列表到指定位置--带缓冲效果 (y=0回到顶部;如果要滚动到底部可以传一个较大的值,比如99999);t时长,单位ms,默认300 */\r\n  MeScroll.prototype.scrollTo = function (y, t) {\r\n    var me = this;\r\n    var star = me.getScrollTop();\r\n    var end = y;\r\n    if (end > 0) {\r\n      var maxY = me.getScrollHeight() - me.getClientHeight(); // y的最大值\r\n      if (end > maxY) end = maxY; // 不可超过最大值\r\n    } else {\r\n      end = 0; // 不可小于0\r\n    }\r\n    me.isScrollTo = true; // 标记在滑动中,阻止列表的触摸事件\r\n    me.scrollDom.style.webkitOverflowScrolling = 'auto';\r\n    me.getStep(star, end, function (step) {\r\n      me.setScrollTop(step);\r\n      if (step === end) {\r\n        me.scrollDom.style.webkitOverflowScrolling = 'touch';\r\n        me.isScrollTo = false;\r\n      }\r\n    }, t)\r\n  }\r\n\r\n  /* 计步器\r\n     star: 开始值\r\n     end: 结束值\r\n     callback(step,timer): 回调step值,计步器timer,可自行通过window.clearInterval(timer)结束计步器;\r\n     t: 计步时长,传0则直接回调end值;不传则默认300ms\r\n     rate: 周期;不传则默认30ms计步一次\r\n     * */\r\n  MeScroll.prototype.getStep = function (star, end, callback, t, rate) {\r\n    var diff = end - star; // 差值\r\n    if (t === 0 || diff === 0) {\r\n      callback && callback(end);\r\n      return;\r\n    }\r\n    t = t || 300; // 时长 300ms\r\n    rate = rate || 30; // 周期 30ms\r\n    var count = t / rate; // 次数\r\n    var step = diff / count; // 步长\r\n    var i = 0; // 计数\r\n    var timer = window.setInterval(function () {\r\n      if (i < count - 1) {\r\n        star += step;\r\n        callback && callback(star, timer);\r\n        i++;\r\n      } else {\r\n        callback && callback(end, timer); // 最后一次直接设置end,避免计算误差\r\n        window.clearInterval(timer);\r\n      }\r\n    }, rate);\r\n  }\r\n\r\n  /* 加载可视区域的图片 */\r\n  MeScroll.prototype.lazyLoad = function (delay) {\r\n    var me = this;\r\n    var t = delay != null ? delay : me.optUp.lazyLoad.delay; // delay需支持传0,不使用短路求值\r\n    var timer = setTimeout(function () {\r\n      var domArr = me.scrollDom.querySelectorAll('[' + me.optUp.lazyLoad.attr + ']');\r\n      var len = domArr.length;\r\n      for (var i = 0; i < len; i++) {\r\n        var dom = domArr[i];\r\n        if (dom.getAttribute(me.lazyTag) !== 'true' && me.isInSee(dom, me.optUp.lazyLoad.offset)) {\r\n          var imgurl = dom.getAttribute(me.optUp.lazyLoad.attr);\r\n          // 采用临时img标签加载网络图: 1.不影响占位图; 2.成功可设置渐变动画; 3.失败后可重新触发加载;\r\n          var temp = new Image();\r\n          temp.onload = function () {\r\n            var imgurl = this.src;// 需通过this取值\r\n            var dom = this.dom;\r\n            var showClass = me.optUp.lazyLoad.showClass;// 渐变动画\r\n            showClass && dom.classList.add(showClass);\r\n            if (dom.tagName === 'IMG') {\r\n              dom.src = imgurl;// 如果是img标签,则直接设置src\r\n            } else {\r\n              dom.style.backgroundImage = 'url(' + imgurl + ')';// 如果其他标签,则直接设置背景\r\n            }\r\n            dom.removeAttribute(me.optUp.lazyLoad.attr);\r\n            dom.removeAttribute(me.lazyTag);\r\n          }\r\n          temp.onerror = function () {\r\n            this.dom.removeAttribute(me.lazyTag);// 失败的时候取消加载中的标记\r\n          }\r\n          temp.onabort = function () {\r\n            this.dom.removeAttribute(me.lazyTag);// 失败的时候取消加载中的标记\r\n          }\r\n          temp.src = imgurl;\r\n          // 标记在加载中..\r\n          dom.setAttribute(me.lazyTag, 'true');\r\n          // 把dom挂载到temp,确保在for循环的temp.onload能够正确取到对应的dom\r\n          temp.dom = dom;\r\n        }\r\n      }\r\n    }, t)\r\n    return timer;\r\n  }\r\n\r\n  /* 判断元素是否在列表垂直区域可视 (不考虑scrollLeft的情况,因为没法监听每个div的水平滚动事件,也不考虑translateY的情况,因为情况比较少,且会增加计算的复杂度) */\r\n  MeScroll.prototype.isInSee = function (dom, offset) {\r\n    offset = offset || 0; // 可视区域上下偏移的距离\r\n    var topDom = this.getOffsetTop(dom);// 元素顶部到容器顶部的距离\r\n    var topSee = this.getScrollTop() - offset;// 滚动条的位置(可视范围的顶部)\r\n    var bottomDom = topDom + dom.offsetHeight;// 元素底部到容器顶部的距离\r\n    var bottomSee = topSee + offset + this.getClientHeight() + offset;// 滚动条的位置+容器高度(可视范围的底部)\r\n    // 图片顶部在可视范围内 || 图片底部在可视范围 ; 不考虑scrollLeft和translateY的情况\r\n    return (topDom < bottomSee && topDom >= topSee) || (bottomDom <= bottomSee && bottomDom > topSee);\r\n  }\r\n\r\n  /* 获取元素到mescroll滚动列表顶部的距离 */\r\n  MeScroll.prototype.getOffsetTop = function (dom) {\r\n    var top = dom.offsetTop;\r\n    var parent = dom.offsetParent;\r\n    while (parent != null && parent !== this.scrollDom) {\r\n      top += parent.offsetTop + parent.clientTop;\r\n      parent = parent.offsetParent;\r\n    }\r\n    return top;\r\n  }\r\n\r\n  /* 滚动内容的高度 */\r\n  MeScroll.prototype.getScrollHeight = function () {\r\n    return this.scrollDom.scrollHeight;\r\n  }\r\n\r\n  /* 滚动容器的高度 */\r\n  MeScroll.prototype.getClientHeight = function () {\r\n    if (this.isScrollBody && document.compatMode === 'CSS1Compat') {\r\n      return document.documentElement.clientHeight;\r\n    } else {\r\n      return this.scrollDom.clientHeight;\r\n    }\r\n  }\r\n\r\n  /* body的高度 */\r\n  MeScroll.prototype.getBodyHeight = function () {\r\n    return document.body.clientHeight || document.documentElement.clientHeight;\r\n  }\r\n\r\n  /* 滚动条的位置 */\r\n  MeScroll.prototype.getScrollTop = function () {\r\n    if (this.isScrollBody) {\r\n      return document.documentElement.scrollTop || document.body.scrollTop;\r\n    } else {\r\n      return this.scrollDom.scrollTop;\r\n    }\r\n  }\r\n\r\n  /* 滚动条到底部的距离 */\r\n  MeScroll.prototype.getToBottom = function () {\r\n    return this.getScrollHeight() - this.getClientHeight() - this.getScrollTop();\r\n  }\r\n\r\n  /* 设置滚动条的位置 */\r\n  MeScroll.prototype.setScrollTop = function (y) {\r\n    if (typeof y === 'number') {\r\n      if (this.isScrollBody) {\r\n        document.documentElement.scrollTop = y;\r\n        document.body.scrollTop = y;\r\n      } else {\r\n        this.scrollDom.scrollTop = y;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* 查找dom元素 */\r\n  MeScroll.prototype.getDomById = function (id) {\r\n    var dom;\r\n    if (id) {\r\n      if (typeof id === 'string') {\r\n        dom = document.getElementById(id); // 如果是String,则根据id查找\r\n      } else if (id.nodeType) {\r\n        dom = id; // 如果是dom对象,则直接赋值\r\n      }\r\n    }\r\n    if (!dom) console.error('the element with id as \"' + id + '\" can not be found: document.getElementById(\"' + id + '\")==null');\r\n    return dom;\r\n  }\r\n\r\n  /* 删除dom元素 */\r\n  MeScroll.prototype.removeChild = function (dom) {\r\n    if (dom) {\r\n      var parent = dom.parentNode;\r\n      parent && parent.removeChild(dom);\r\n      dom = null;\r\n    }\r\n  }\r\n\r\n  /* 销毁mescroll */\r\n  MeScroll.prototype.destroy = function () {\r\n    var me = this;\r\n\r\n    // 移除下拉布局,移除事件\r\n    me.scrollDom.removeEventListener('touchstart', me.touchstartEvent); // 移动端手指事件\r\n    me.scrollDom.removeEventListener('touchmove', me.touchmoveEvent); // 移动端手指事件\r\n    me.scrollDom.removeEventListener('touchend', me.touchendEvent); // 移动端手指事件\r\n    me.scrollDom.removeEventListener('touchcancel', me.touchendEvent); // 移动端手指事件\r\n    me.scrollDom.removeEventListener('mousedown', me.touchstartEvent); // PC端鼠标事件\r\n    me.scrollDom.removeEventListener('mousemove', me.touchmoveEvent); // PC端鼠标事件\r\n    me.scrollDom.removeEventListener('mouseup', me.touchendEvent); // PC端鼠标抬起事件\r\n    me.scrollDom.removeEventListener('mouseleave', me.touchendEvent); // PC端鼠标离开事件\r\n    me.removeChild(me.downwarp); // 下拉布局\r\n\r\n    // 移除上拉布局,回到顶部按钮,移除事件\r\n    if (me.isScrollBody) {\r\n      window.removeEventListener('scroll', me.scrollEvent); // window的滚动事件\r\n    } else {\r\n      me.scrollDom.removeEventListener('scroll', me.scrollEvent); // div的滚动事件\r\n    }\r\n    me.removeChild(me.upwarp); // 上拉布局\r\n    me.removeChild(me.toTopBtn); // 回到顶部按钮\r\n\r\n    // 允许回弹,解除禁止webview的touchmove事件\r\n    me.setBounce(true);\r\n  }\r\n\r\n  return MeScroll;\r\n});\r\n"],"sourceRoot":""}